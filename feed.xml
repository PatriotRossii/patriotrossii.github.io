<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://eoanermine.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://eoanermine.com/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-09T16:16:44+00:00</updated><id>https://eoanermine.com/feed.xml</id><title type="html">blank</title><subtitle>Danil Sidoruk&apos;s (aka eoanermine) personal blog
</subtitle><entry><title type="html">Краткий обзор нововведений C++23: deducing this</title><link href="https://eoanermine.com/2023/c23-deducing-this/" rel="alternate" type="text/html" title="Краткий обзор нововведений C++23: deducing this" /><published>2023-03-16T14:59:05+00:00</published><updated>2023-03-16T14:59:05+00:00</updated><id>https://eoanermine.com/2023/---c23-deducing-this</id><content type="html" xml:base="https://eoanermine.com/2023/c23-deducing-this/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Документ «deducing this», принятый в последний стандарт C++, вводит новый, третий тип методов классов, сочетающий в себе свойства двух уже существующих: нестатических и статических, открывающий перед нами новые горизонты:1. Дедупликация большого количества кода.2. Вытеснение CRTP (Curiously Recuring Template Pattern) на свалку истории, его замена более простой и очевидно понятной записью.3. Рекурсивные лямбды.И другое.Но прежде чем рассмотреть само нововведение и его практические применения, углубимся немного в историю и попытаемся понять, почему в нем собственно возникла необходимость. Читать далее]]></summary></entry><entry><title type="html">Введение в метаклассы</title><link href="https://eoanermine.com/2022/" rel="alternate" type="text/html" title="Введение в метаклассы" /><published>2022-08-31T11:41:28+00:00</published><updated>2022-08-31T11:41:28+00:00</updated><id>https://eoanermine.com/--</id><content type="html" xml:base="https://eoanermine.com/2022/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[В стандартной библиотеке языка программирования C++ существует много классов, наделенных если не абсолютно одинаковыми свойствами, то очень похожими.Так, стандарт вводит отдельное требование BitmaskType, описывающее свойства, какими должны обладать битовые маски в стандартной библиотеке: для них должен быть определены операции «и», «или», «не», а значение 0 должно представлять пустую маску.В стандартной библиотеке классов, от которых требуется соблюдение этого требования, очень много: std::chars_format, std::launch, std::filesystem::perms, std::filesystem::perm_options, std::filesystem::copy_options, std::filesystem::directory_options... Единственное, чем они отличаются — это набором возможных значений. Реализации же битовых операций над ними похожи как две капли воды.В данной статье мы поговорим о том, как такое средство как метаклассы в некоторых случаях способно спасти программиста от написания простынь бойлерплейта. Читать далее]]></summary></entry></feed>